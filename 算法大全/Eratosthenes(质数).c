/*
 Eratosthenes
 筛选求质数
 说明除了自身之外，无法被其它整数整除的数称之为质数，要求质数很简单，但如何快速的
 求出质数则一直是程式设计人员与数学家努力的课题，在这边介绍一个着名的Eratosthenes求质
 数方法。
 解法
 首先知道这个问题可以使用回圈来求解，将一个指定的数除以所有小于它的数，若可以
 整除就不是质数，然而如何减少回圈的检查次数？如何求出小于N的所有质数？
 首先假设要检查的数是N好了，则事实上只要检查至N的开根号就可以了，道理很简单，假设
 A*B = N，如果A大于N的开根号，则事实上在小于A之前的检查就可以先检查到B这个数可以整
 除N。不过在程式中使用开根号会精确度的问题，所以可以使用i*i <= N进行检查，且执行更快。
 再来假设有一个筛子存放1～N，例如：
 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ........ N
 先将2的倍数筛去： 2 3 5 7 9 11 13 15 17 19 21 ........ N
 再将3的倍数筛去： 2 3 5 7 11 13 17 19 ........ N
 再来将5的倍数筛去，再来将7的质数筛去，再来将11的倍数筛去........，如此进行到最后留下的
 数就都是质数，这就是Eratosthenes筛选方法（Eratosthenes Sieve Method）。
 检查的次数还可以再减少，事实上，只要检查6n+1与6n+5就可以了，也就是直接跳过2与3的倍
 数，使得程式中的if的检查动作可以减少。
*/

#include <stdio.h>
#include <stdlib.h>
#define N 1000
int main(void) {
    int i, j;
    int prime[N+1];
    for(i = 2; i <= N; i++)
        prime[i] = 1;
    for(i = 2; i*i <= N; i++) { // 这边可以改进
        if(prime[i] == 1) {
            for(j = 2*i; j <= N; j++) {
                if(j % i == 0)
                    prime[j] = 0;
            }
        }
    }
    for(i = 2; i < N; i++) {
        if(prime[i] == 1) {
            printf("%4d ", i);
            if(i % 16 == 0)
                printf("\n");
        }
    }
    printf("\n");
    return 0;
}